{"ast":null,"code":"import { Injectable, InjectionToken, Component, ElementRef, Renderer2, HostListener, EventEmitter, Directive, ViewContainerRef, Optional, Inject, Input, Output, RendererFactory2, NgModule } from '@angular/core';\nimport { isBs3, Utils, document as document$1, window as window$1 } from 'ngx-bootstrap/utils';\nimport { ComponentLoaderFactory } from 'ngx-bootstrap/component-loader';\nimport { PositioningService } from 'ngx-bootstrap/positioning';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @template T\n */\n// tslint:disable-next-line:no-any\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from 'ngx-bootstrap/component-loader';\nconst _c0 = [\"*\"];\nlet BsModalRef = /*#__PURE__*/(() => {\n  class BsModalRef {\n    constructor() {\n      /**\n       * Hides the modal\n       */\n      this.hide = Function;\n      /**\n       * Sets new class to modal window\n       */\n\n      this.setClass = Function;\n    }\n\n  }\n\n  BsModalRef.ɵfac = function BsModalRef_Factory(t) {\n    return new (t || BsModalRef)();\n  };\n\n  BsModalRef.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: BsModalRef,\n    factory: BsModalRef.ɵfac\n  });\n  return BsModalRef;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   *  Allow user to ID for the modal. Otherwise, a unique number will be given\n   * @type {?}\n   */\n  BsModalRef.prototype.id;\n  /**\n   * Reference to a component inside the modal. Null if modal's been created with TemplateRef\n   * @type {?}\n   */\n\n  BsModalRef.prototype.content;\n  /**\n   * Hides the modal\n   * @type {?}\n   */\n\n  BsModalRef.prototype.hide;\n  /**\n   * Sets new class to modal window\n   * @type {?}\n   */\n\n  BsModalRef.prototype.setClass;\n  /**\n   * Event that is fired when the modal behind the ref starts hiding\n   * @type {?}\n   */\n\n  BsModalRef.prototype.onHide;\n  /**\n   * Event that is fired when the modal behind the ref finishes hiding\n   * @type {?}\n   */\n\n  BsModalRef.prototype.onHidden;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nclass ModalBackdropOptions {\n  /**\n   * @param {?} options\n   */\n  constructor(options) {\n    this.animate = true;\n    Object.assign(this, options);\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  ModalBackdropOptions.prototype.animate;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @template T\n */\n\n\nlet ModalOptions = /*#__PURE__*/(() => {\n  class ModalOptions {}\n\n  ModalOptions.ɵfac = function ModalOptions_Factory(t) {\n    return new (t || ModalOptions)();\n  };\n\n  ModalOptions.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: ModalOptions,\n    factory: ModalOptions.ɵfac\n  });\n  return ModalOptions;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   *  Allow user to ID for the modal. Otherwise, a unique number will be given\n   * @type {?}\n   */\n  ModalOptions.prototype.id;\n  /**\n   *  Includes a modal-backdrop element. Alternatively,\n   *  specify static for a backdrop which doesn't close the modal on click.\n   * @type {?}\n   */\n\n  ModalOptions.prototype.backdrop;\n  /**\n   * Closes the modal when escape key is pressed.\n   * @type {?}\n   */\n\n  ModalOptions.prototype.keyboard;\n  /** @type {?} */\n\n  ModalOptions.prototype.focus;\n  /**\n   * Shows the modal when initialized.\n   * @type {?}\n   */\n\n  ModalOptions.prototype.show;\n  /**\n   * Ignore the backdrop click\n   * @type {?}\n   */\n\n  ModalOptions.prototype.ignoreBackdropClick;\n  /**\n   * Css class for opened modal\n   * @type {?}\n   */\n\n  ModalOptions.prototype.class;\n  /**\n   * Toggle animation\n   * @type {?}\n   */\n\n  ModalOptions.prototype.animated;\n  /**\n   * Modal data\n   * @type {?}\n   */\n\n  ModalOptions.prototype.initialState;\n  /**\n   * Modal providers\n   * @type {?}\n   */\n\n  ModalOptions.prototype.providers;\n  /**\n   * aria-labelledby attribute value to set on the modal window\n   * @type {?}\n   */\n\n  ModalOptions.prototype.ariaLabelledBy;\n  /**\n   * aria-describedby attribute value to set on the modal window\n   * @type {?}\n   */\n\n  ModalOptions.prototype.ariaDescribedby;\n}\n/** @type {?} */\n\n\nconst modalConfigDefaults = {\n  backdrop: true,\n  keyboard: true,\n  focus: true,\n  show: false,\n  ignoreBackdropClick: false,\n  class: '',\n  animated: true,\n  initialState: {}\n};\n/** @type {?} */\n\nconst MODAL_CONFIG_DEFAULT_OVERRIDE = new InjectionToken('override-default-config');\n/** @type {?} */\n\nconst CLASS_NAME = {\n  SCROLLBAR_MEASURER: 'modal-scrollbar-measure',\n  BACKDROP: 'modal-backdrop',\n  OPEN: 'modal-open',\n  FADE: 'fade',\n  IN: 'in',\n  // bs3\n  SHOW: 'show' // bs4\n\n};\n/** @type {?} */\n\nconst SELECTOR = {\n  DIALOG: '.modal-dialog',\n  DATA_TOGGLE: '[data-toggle=\"modal\"]',\n  DATA_DISMISS: '[data-dismiss=\"modal\"]',\n  FIXED_CONTENT: '.navbar-fixed-top, .navbar-fixed-bottom, .is-fixed'\n};\n/** @type {?} */\n\nconst TRANSITION_DURATIONS = {\n  MODAL: 300,\n  BACKDROP: 150\n};\n/** @type {?} */\n\nconst DISMISS_REASONS = {\n  BACKRDOP: 'backdrop-click',\n  ESC: 'esc',\n  BACK: 'browser-back-navigation-clicked'\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nlet ModalContainerComponent = /*#__PURE__*/(() => {\n  class ModalContainerComponent {\n    /**\n     * @param {?} options\n     * @param {?} _element\n     * @param {?} _renderer\n     */\n    constructor(options, _element, _renderer) {\n      this._element = _element;\n      this._renderer = _renderer;\n      this.isShown = false;\n      this.isModalHiding = false;\n      this.clickStartedInContent = false;\n      this.config = Object.assign({}, options);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnInit() {\n      if (this.isAnimated) {\n        this._renderer.addClass(this._element.nativeElement, CLASS_NAME.FADE);\n      }\n\n      this._renderer.setStyle(this._element.nativeElement, 'display', 'block');\n\n      setTimeout(\n      /**\n      * @return {?}\n      */\n      () => {\n        this.isShown = true;\n\n        this._renderer.addClass(this._element.nativeElement, isBs3() ? CLASS_NAME.IN : CLASS_NAME.SHOW);\n      }, this.isAnimated ? TRANSITION_DURATIONS.BACKDROP : 0);\n\n      if (document && document.body) {\n        if (this.bsModalService.getModalsCount() === 1) {\n          this.bsModalService.checkScrollbar();\n          this.bsModalService.setScrollbar();\n        }\n\n        this._renderer.addClass(document.body, CLASS_NAME.OPEN);\n      }\n\n      if (this._element.nativeElement) {\n        this._element.nativeElement.focus();\n      }\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n\n\n    onClickStarted(event) {\n      this.clickStartedInContent = event.target !== this._element.nativeElement;\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n\n\n    onClickStop(event) {\n      /** @type {?} */\n      const clickedInBackdrop = event.target === this._element.nativeElement && !this.clickStartedInContent;\n\n      if (this.config.ignoreBackdropClick || this.config.backdrop === 'static' || !clickedInBackdrop) {\n        this.clickStartedInContent = false;\n        return;\n      }\n\n      this.bsModalService.setDismissReason(DISMISS_REASONS.BACKRDOP);\n      this.hide();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    onPopState() {\n      this.bsModalService.setDismissReason(DISMISS_REASONS.BACK);\n      this.hide();\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n\n\n    onEsc(event) {\n      if (!this.isShown) {\n        return;\n      } // tslint:disable-next-line:deprecation\n\n\n      if (event.keyCode === 27 || event.key === 'Escape') {\n        event.preventDefault();\n      }\n\n      if (this.config.keyboard && this.level === this.bsModalService.getModalsCount()) {\n        this.bsModalService.setDismissReason(DISMISS_REASONS.ESC);\n        this.hide();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      if (this.isShown) {\n        this.hide();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    hide() {\n      if (this.isModalHiding || !this.isShown) {\n        return;\n      }\n\n      this.isModalHiding = true;\n\n      this._renderer.removeClass(this._element.nativeElement, isBs3() ? CLASS_NAME.IN : CLASS_NAME.SHOW);\n\n      setTimeout(\n      /**\n      * @return {?}\n      */\n      () => {\n        this.isShown = false;\n\n        if (document && document.body && this.bsModalService.getModalsCount() === 1) {\n          this._renderer.removeClass(document.body, CLASS_NAME.OPEN);\n        }\n\n        this.bsModalService.hide(this.config.id);\n        this.isModalHiding = false;\n      }, this.isAnimated ? TRANSITION_DURATIONS.MODAL : 0);\n    }\n\n  }\n\n  ModalContainerComponent.ɵfac = function ModalContainerComponent_Factory(t) {\n    return new (t || ModalContainerComponent)(ɵngcc0.ɵɵdirectiveInject(ModalOptions), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2));\n  };\n\n  ModalContainerComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: ModalContainerComponent,\n    selectors: [[\"modal-container\"]],\n    hostAttrs: [\"role\", \"dialog\", \"tabindex\", \"-1\", 1, \"modal\"],\n    hostVars: 3,\n    hostBindings: function ModalContainerComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"mousedown\", function ModalContainerComponent_mousedown_HostBindingHandler($event) {\n          return ctx.onClickStarted($event);\n        })(\"mouseup\", function ModalContainerComponent_mouseup_HostBindingHandler($event) {\n          return ctx.onClickStop($event);\n        })(\"popstate\", function ModalContainerComponent_popstate_HostBindingHandler() {\n          return ctx.onPopState();\n        }, false, ɵngcc0.ɵɵresolveWindow)(\"keydown.esc\", function ModalContainerComponent_keydown_esc_HostBindingHandler($event) {\n          return ctx.onEsc($event);\n        }, false, ɵngcc0.ɵɵresolveWindow);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"aria-modal\", true)(\"aria-labelledby\", ctx.config.ariaLabelledBy)(\"aria-describedby\", ctx.config.ariaDescribedby);\n      }\n    },\n    ngContentSelectors: _c0,\n    decls: 3,\n    vars: 2,\n    consts: [[\"role\", \"document\"], [1, \"modal-content\"]],\n    template: function ModalContainerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n        ɵngcc0.ɵɵelementStart(1, \"div\", 1);\n        ɵngcc0.ɵɵprojection(2);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassMap(\"modal-dialog\" + (ctx.config.class ? \" \" + ctx.config.class : \"\"));\n      }\n    },\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return ModalContainerComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /** @type {?} */\n  ModalContainerComponent.prototype.config;\n  /** @type {?} */\n\n  ModalContainerComponent.prototype.isShown;\n  /** @type {?} */\n\n  ModalContainerComponent.prototype.level;\n  /** @type {?} */\n\n  ModalContainerComponent.prototype.isAnimated;\n  /** @type {?} */\n\n  ModalContainerComponent.prototype.bsModalService;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ModalContainerComponent.prototype.isModalHiding;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ModalContainerComponent.prototype.clickStartedInContent;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  ModalContainerComponent.prototype._element;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ModalContainerComponent.prototype._renderer;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * This component will be added as background layout for modals if enabled\n */\n\n\nlet ModalBackdropComponent = /*#__PURE__*/(() => {\n  class ModalBackdropComponent {\n    /**\n     * @param {?} element\n     * @param {?} renderer\n     */\n    constructor(element, renderer) {\n      this._isShown = false;\n      this.element = element;\n      this.renderer = renderer;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get isAnimated() {\n      return this._isAnimated;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set isAnimated(value) {\n      this._isAnimated = value; // this.renderer.setElementClass(this.element.nativeElement, `${ClassName.FADE}`, value);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get isShown() {\n      return this._isShown;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set isShown(value) {\n      this._isShown = value;\n\n      if (value) {\n        this.renderer.addClass(this.element.nativeElement, `${CLASS_NAME.IN}`);\n      } else {\n        this.renderer.removeClass(this.element.nativeElement, `${CLASS_NAME.IN}`);\n      }\n\n      if (!isBs3()) {\n        if (value) {\n          this.renderer.addClass(this.element.nativeElement, `${CLASS_NAME.SHOW}`);\n        } else {\n          this.renderer.removeClass(this.element.nativeElement, `${CLASS_NAME.SHOW}`);\n        }\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnInit() {\n      if (this.isAnimated) {\n        this.renderer.addClass(this.element.nativeElement, `${CLASS_NAME.FADE}`);\n        Utils.reflow(this.element.nativeElement);\n      }\n\n      this.isShown = true;\n    }\n\n  }\n\n  ModalBackdropComponent.ɵfac = function ModalBackdropComponent_Factory(t) {\n    return new (t || ModalBackdropComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2));\n  };\n\n  ModalBackdropComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: ModalBackdropComponent,\n    selectors: [[\"bs-modal-backdrop\"]],\n    hostAttrs: [1, \"modal-backdrop\"],\n    decls: 0,\n    vars: 0,\n    template: function ModalBackdropComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return ModalBackdropComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /** @type {?} */\n  ModalBackdropComponent.prototype.element;\n  /** @type {?} */\n\n  ModalBackdropComponent.prototype.renderer;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  ModalBackdropComponent.prototype._isAnimated;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  ModalBackdropComponent.prototype._isShown;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nconst TRANSITION_DURATION = 300;\n/** @type {?} */\n\nconst BACKDROP_TRANSITION_DURATION = 150;\n/**\n * Mark any code with directive to show it's content in modal\n */\n\nlet ModalDirective = /*#__PURE__*/(() => {\n  class ModalDirective {\n    /**\n     * @param {?} _element\n     * @param {?} _viewContainerRef\n     * @param {?} _renderer\n     * @param {?} clf\n     * @param {?} modalDefaultOption\n     */\n    constructor(_element, _viewContainerRef, _renderer, clf, modalDefaultOption) {\n      this._element = _element;\n      this._renderer = _renderer;\n      /**\n       * This event fires immediately when the `show` instance method is called.\n       */\n\n      this.onShow = new EventEmitter();\n      /**\n       * This event is fired when the modal has been made visible to the user\n       * (will wait for CSS transitions to complete)\n       */\n\n      this.onShown = new EventEmitter();\n      /**\n       * This event is fired immediately when\n       * the hide instance method has been called.\n       */\n\n      this.onHide = new EventEmitter();\n      /**\n       * This event is fired when the modal has finished being\n       * hidden from the user (will wait for CSS transitions to complete).\n       */\n\n      this.onHidden = new EventEmitter();\n      this._isShown = false;\n      this.isBodyOverflowing = false;\n      this.originalBodyPadding = 0;\n      this.scrollbarWidth = 0;\n      this.timerHideModal = 0;\n      this.timerRmBackDrop = 0;\n      this.isNested = false;\n      this.clickStartedInContent = false;\n      this._backdrop = clf.createLoader(_element, _viewContainerRef, _renderer);\n      this._config = modalDefaultOption || modalConfigDefaults;\n    }\n    /**\n     * allows to set modal configuration via element property\n     * @param {?} conf\n     * @return {?}\n     */\n\n\n    set config(conf) {\n      this._config = this.getConfig(conf);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get config() {\n      return this._config;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get isShown() {\n      return this._isShown;\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n\n\n    onClickStarted(event) {\n      this.clickStartedInContent = event.target !== this._element.nativeElement;\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n\n\n    onClickStop(event) {\n      /** @type {?} */\n      const clickedInBackdrop = event.target === this._element.nativeElement && !this.clickStartedInContent;\n\n      if (this.config.ignoreBackdropClick || this.config.backdrop === 'static' || !clickedInBackdrop) {\n        this.clickStartedInContent = false;\n        return;\n      }\n\n      this.dismissReason = DISMISS_REASONS.BACKRDOP;\n      this.hide(event);\n    } // todo: consider preventing default and stopping propagation\n\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n\n\n    onEsc(event) {\n      if (!this._isShown) {\n        return;\n      } // tslint:disable-next-line:deprecation\n\n\n      if (event.keyCode === 27 || event.key === 'Escape') {\n        event.preventDefault();\n      }\n\n      if (this.config.keyboard) {\n        this.dismissReason = DISMISS_REASONS.ESC;\n        this.hide();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      this.config = void 0;\n\n      if (this._isShown) {\n        this._isShown = false;\n        this.hideModal();\n\n        this._backdrop.dispose();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnInit() {\n      this._config = this._config || this.getConfig();\n      setTimeout(\n      /**\n      * @return {?}\n      */\n      () => {\n        if (this._config.show) {\n          this.show();\n        }\n      }, 0);\n    }\n    /* Public methods */\n\n    /**\n     * Allows to manually toggle modal visibility\n     * @return {?}\n     */\n\n\n    toggle() {\n      return this._isShown ? this.hide() : this.show();\n    }\n    /**\n     * Allows to manually open modal\n     * @return {?}\n     */\n\n\n    show() {\n      this.dismissReason = null;\n      this.onShow.emit(this);\n\n      if (this._isShown) {\n        return;\n      }\n\n      clearTimeout(this.timerHideModal);\n      clearTimeout(this.timerRmBackDrop);\n      this._isShown = true;\n      this.checkScrollbar();\n      this.setScrollbar();\n\n      if (document$1 && document$1.body) {\n        if (document$1.body.classList.contains(CLASS_NAME.OPEN)) {\n          this.isNested = true;\n        } else {\n          this._renderer.addClass(document$1.body, CLASS_NAME.OPEN);\n        }\n      }\n\n      this.showBackdrop(\n      /**\n      * @return {?}\n      */\n      () => {\n        this.showElement();\n      });\n    }\n    /**\n     * Allows to manually close modal\n     * @param {?=} event\n     * @return {?}\n     */\n\n\n    hide(event) {\n      if (event) {\n        event.preventDefault();\n      }\n\n      this.onHide.emit(this); // todo: add an option to prevent hiding\n\n      if (!this._isShown) {\n        return;\n      }\n\n      window$1.clearTimeout(this.timerHideModal);\n      window$1.clearTimeout(this.timerRmBackDrop);\n      this._isShown = false;\n\n      this._renderer.removeClass(this._element.nativeElement, CLASS_NAME.IN);\n\n      if (!isBs3()) {\n        this._renderer.removeClass(this._element.nativeElement, CLASS_NAME.SHOW);\n      } // this._addClassIn = false;\n\n\n      if (this._config.animated) {\n        this.timerHideModal = window$1.setTimeout(\n        /**\n        * @return {?}\n        */\n        () => this.hideModal(), TRANSITION_DURATION);\n      } else {\n        this.hideModal();\n      }\n    }\n    /**\n     * Private methods \\@internal\n     * @protected\n     * @param {?=} config\n     * @return {?}\n     */\n\n\n    getConfig(config) {\n      return Object.assign({}, this._config, config);\n    }\n    /**\n     *  Show dialog\n     * \\@internal\n     * @protected\n     * @return {?}\n     */\n\n\n    showElement() {\n      // todo: replace this with component loader usage\n      if (!this._element.nativeElement.parentNode || this._element.nativeElement.parentNode.nodeType !== Node.ELEMENT_NODE) {\n        // don't move modals dom position\n        if (document$1 && document$1.body) {\n          document$1.body.appendChild(this._element.nativeElement);\n        }\n      }\n\n      this._renderer.setAttribute(this._element.nativeElement, 'aria-hidden', 'false');\n\n      this._renderer.setAttribute(this._element.nativeElement, 'aria-modal', 'true');\n\n      this._renderer.setStyle(this._element.nativeElement, 'display', 'block');\n\n      this._renderer.setProperty(this._element.nativeElement, 'scrollTop', 0);\n\n      if (this._config.animated) {\n        Utils.reflow(this._element.nativeElement);\n      } // this._addClassIn = true;\n\n\n      this._renderer.addClass(this._element.nativeElement, CLASS_NAME.IN);\n\n      if (!isBs3()) {\n        this._renderer.addClass(this._element.nativeElement, CLASS_NAME.SHOW);\n      }\n      /** @type {?} */\n\n\n      const transitionComplete =\n      /**\n      * @return {?}\n      */\n      () => {\n        if (this._config.focus) {\n          this._element.nativeElement.focus();\n        }\n\n        this.onShown.emit(this);\n      };\n\n      if (this._config.animated) {\n        setTimeout(transitionComplete, TRANSITION_DURATION);\n      } else {\n        transitionComplete();\n      }\n    }\n    /**\n     * \\@internal\n     * @protected\n     * @return {?}\n     */\n\n\n    hideModal() {\n      this._renderer.setAttribute(this._element.nativeElement, 'aria-hidden', 'true');\n\n      this._renderer.setStyle(this._element.nativeElement, 'display', 'none');\n\n      this.showBackdrop(\n      /**\n      * @return {?}\n      */\n      () => {\n        if (!this.isNested) {\n          if (document$1 && document$1.body) {\n            this._renderer.removeClass(document$1.body, CLASS_NAME.OPEN);\n          }\n\n          this.resetScrollbar();\n        }\n\n        this.resetAdjustments();\n        this.focusOtherModal();\n        this.onHidden.emit(this);\n      });\n    } // todo: original show was calling a callback when done, but we can use\n    // promise\n\n    /**\n     * \\@internal\n     * @protected\n     * @param {?=} callback\n     * @return {?}\n     */\n\n\n    showBackdrop(callback) {\n      if (this._isShown && this.config.backdrop && (!this.backdrop || !this.backdrop.instance.isShown)) {\n        this.removeBackdrop();\n\n        this._backdrop.attach(ModalBackdropComponent).to('body').show({\n          isAnimated: this._config.animated\n        });\n\n        this.backdrop = this._backdrop._componentRef;\n\n        if (!callback) {\n          return;\n        }\n\n        if (!this._config.animated) {\n          callback();\n          return;\n        }\n\n        setTimeout(callback, BACKDROP_TRANSITION_DURATION);\n      } else if (!this._isShown && this.backdrop) {\n        this.backdrop.instance.isShown = false;\n        /** @type {?} */\n\n        const callbackRemove =\n        /**\n        * @return {?}\n        */\n        () => {\n          this.removeBackdrop();\n\n          if (callback) {\n            callback();\n          }\n        };\n\n        if (this.backdrop.instance.isAnimated) {\n          this.timerRmBackDrop = window$1.setTimeout(callbackRemove, BACKDROP_TRANSITION_DURATION);\n        } else {\n          callbackRemove();\n        }\n      } else if (callback) {\n        callback();\n      }\n    }\n    /**\n     * \\@internal\n     * @protected\n     * @return {?}\n     */\n\n\n    removeBackdrop() {\n      this._backdrop.hide();\n    }\n    /**\n     * Events tricks\n     * @protected\n     * @return {?}\n     */\n    // no need for it\n    // protected setEscapeEvent():void {\n    //   if (this._isShown && this._config.keyboard) {\n    //     $(this._element).on(Event.KEYDOWN_DISMISS, (event) => {\n    //       if (event.which === 27) {\n    //         this.hide()\n    //       }\n    //     })\n    //\n    //   } else if (!this._isShown) {\n    //     $(this._element).off(Event.KEYDOWN_DISMISS)\n    //   }\n    // }\n    // protected setResizeEvent():void {\n    // console.log(this.renderer.listenGlobal('', Event.RESIZE));\n    // if (this._isShown) {\n    //   $(window).on(Event.RESIZE, $.proxy(this._handleUpdate, this))\n    // } else {\n    //   $(window).off(Event.RESIZE)\n    // }\n    // }\n\n\n    focusOtherModal() {\n      if (this._element.nativeElement.parentElement == null) {\n        return;\n      }\n      /** @type {?} */\n\n\n      const otherOpenedModals = this._element.nativeElement.parentElement.querySelectorAll('.in[bsModal]');\n\n      if (!otherOpenedModals.length) {\n        return;\n      }\n\n      otherOpenedModals[otherOpenedModals.length - 1].focus();\n    }\n    /**\n     * \\@internal\n     * @protected\n     * @return {?}\n     */\n\n\n    resetAdjustments() {\n      this._renderer.setStyle(this._element.nativeElement, 'paddingLeft', '');\n\n      this._renderer.setStyle(this._element.nativeElement, 'paddingRight', '');\n    }\n    /** Scroll bar tricks */\n\n    /**\n     * \\@internal\n     * @protected\n     * @return {?}\n     */\n\n\n    checkScrollbar() {\n      this.isBodyOverflowing = document$1.body.clientWidth < window$1.innerWidth;\n      this.scrollbarWidth = this.getScrollbarWidth();\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n\n\n    setScrollbar() {\n      if (!document$1) {\n        return;\n      }\n\n      this.originalBodyPadding = parseInt(window$1.getComputedStyle(document$1.body).getPropertyValue('padding-right') || 0, 10);\n\n      if (this.isBodyOverflowing) {\n        document$1.body.style.paddingRight = `${this.originalBodyPadding + this.scrollbarWidth}px`;\n      }\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n\n\n    resetScrollbar() {\n      document$1.body.style.paddingRight = `${this.originalBodyPadding}px`;\n    } // thx d.walsh\n\n    /**\n     * @protected\n     * @return {?}\n     */\n\n\n    getScrollbarWidth() {\n      /** @type {?} */\n      const scrollDiv = this._renderer.createElement('div');\n\n      this._renderer.addClass(scrollDiv, CLASS_NAME.SCROLLBAR_MEASURER);\n\n      this._renderer.appendChild(document$1.body, scrollDiv);\n      /** @type {?} */\n\n\n      const scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n\n      this._renderer.removeChild(document$1.body, scrollDiv);\n\n      return scrollbarWidth;\n    }\n\n  }\n\n  ModalDirective.ɵfac = function ModalDirective_Factory(t) {\n    return new (t || ModalDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.ComponentLoaderFactory), ɵngcc0.ɵɵdirectiveInject(MODAL_CONFIG_DEFAULT_OVERRIDE, 8));\n  };\n\n  ModalDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: ModalDirective,\n    selectors: [[\"\", \"bsModal\", \"\"]],\n    hostBindings: function ModalDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"mousedown\", function ModalDirective_mousedown_HostBindingHandler($event) {\n          return ctx.onClickStarted($event);\n        })(\"mouseup\", function ModalDirective_mouseup_HostBindingHandler($event) {\n          return ctx.onClickStop($event);\n        })(\"keydown.esc\", function ModalDirective_keydown_esc_HostBindingHandler($event) {\n          return ctx.onEsc($event);\n        });\n      }\n    },\n    inputs: {\n      config: \"config\"\n    },\n    outputs: {\n      onShow: \"onShow\",\n      onShown: \"onShown\",\n      onHide: \"onHide\",\n      onHidden: \"onHidden\"\n    },\n    exportAs: [\"bs-modal\"]\n  });\n  /** @nocollapse */\n\n  return ModalDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * This event fires immediately when the `show` instance method is called.\n   * @type {?}\n   */\n  ModalDirective.prototype.onShow;\n  /**\n   * This event is fired when the modal has been made visible to the user\n   * (will wait for CSS transitions to complete)\n   * @type {?}\n   */\n\n  ModalDirective.prototype.onShown;\n  /**\n   * This event is fired immediately when\n   * the hide instance method has been called.\n   * @type {?}\n   */\n\n  ModalDirective.prototype.onHide;\n  /**\n   * This event is fired when the modal has finished being\n   * hidden from the user (will wait for CSS transitions to complete).\n   * @type {?}\n   */\n\n  ModalDirective.prototype.onHidden;\n  /**\n   * This field contains last dismiss reason.\n   * Possible values: `backdrop-click`, `esc` and `id: number`\n   * (if modal was closed by direct call of `.hide()`).\n   * @type {?}\n   */\n\n  ModalDirective.prototype.dismissReason;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  ModalDirective.prototype._config;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  ModalDirective.prototype._isShown;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  ModalDirective.prototype.isBodyOverflowing;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  ModalDirective.prototype.originalBodyPadding;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  ModalDirective.prototype.scrollbarWidth;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  ModalDirective.prototype.timerHideModal;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  ModalDirective.prototype.timerRmBackDrop;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  ModalDirective.prototype.backdrop;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ModalDirective.prototype._backdrop;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ModalDirective.prototype.isNested;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ModalDirective.prototype.clickStartedInContent;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ModalDirective.prototype._element;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ModalDirective.prototype._renderer;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet BsModalService = /*#__PURE__*/(() => {\n  class BsModalService {\n    /**\n     * @param {?} rendererFactory\n     * @param {?} clf\n     * @param {?} modalDefaultOption\n     */\n    constructor(rendererFactory, clf, modalDefaultOption) {\n      this.clf = clf;\n      this.modalDefaultOption = modalDefaultOption; // tslint:disable-next-line:no-any\n\n      this.onShow = new EventEmitter(); // tslint:disable-next-line:no-any\n\n      this.onShown = new EventEmitter(); // tslint:disable-next-line:no-any\n\n      this.onHide = new EventEmitter(); // tslint:disable-next-line:no-any\n\n      this.onHidden = new EventEmitter();\n      this.isBodyOverflowing = false;\n      this.originalBodyPadding = 0;\n      this.scrollbarWidth = 0;\n      this.modalsCount = 0;\n      this.lastDismissReason = null;\n      this.loaders = [];\n      this._backdropLoader = this.clf.createLoader(null, null, null);\n      this._renderer = rendererFactory.createRenderer(null, null);\n      this.config = modalDefaultOption ? Object.assign({}, modalConfigDefaults, modalDefaultOption) : modalConfigDefaults;\n    }\n    /**\n     * Shows a modal\n     * @template T\n     * @param {?} content\n     * @param {?=} config\n     * @return {?}\n     */\n\n\n    show( // tslint:disable-next-line:no-any\n    content, config) {\n      this.modalsCount++;\n\n      this._createLoaders();\n      /** @type {?} */\n\n\n      const id = (config === null || config === void 0 ? void 0 : config.id) || new Date().getUTCMilliseconds();\n      this.config = this.modalDefaultOption ? Object.assign({}, modalConfigDefaults, this.modalDefaultOption, config) : Object.assign({}, modalConfigDefaults, config);\n      this.config.id = id;\n\n      this._showBackdrop();\n\n      this.lastDismissReason = null;\n      return this._showModal(content);\n    }\n    /**\n     * @param {?=} id\n     * @return {?}\n     */\n\n\n    hide(id) {\n      if (this.modalsCount === 1 || id == null) {\n        this._hideBackdrop();\n\n        this.resetScrollbar();\n      }\n\n      this.modalsCount = this.modalsCount >= 1 && id != null ? this.modalsCount - 1 : 0;\n      setTimeout(\n      /**\n      * @return {?}\n      */\n      () => {\n        this._hideModal(id);\n\n        this.removeLoaders(id);\n      }, this.config.animated ? TRANSITION_DURATIONS.BACKDROP : 0);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _showBackdrop() {\n      /** @type {?} */\n      const isBackdropEnabled = this.config.backdrop || this.config.backdrop === 'static';\n      /** @type {?} */\n\n      const isBackdropInDOM = !this.backdropRef || !this.backdropRef.instance.isShown;\n\n      if (this.modalsCount === 1) {\n        this.removeBackdrop();\n\n        if (isBackdropEnabled && isBackdropInDOM) {\n          this._backdropLoader.attach(ModalBackdropComponent).to('body').show({\n            isAnimated: this.config.animated\n          });\n\n          this.backdropRef = this._backdropLoader._componentRef;\n        }\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _hideBackdrop() {\n      if (!this.backdropRef) {\n        return;\n      }\n\n      this.backdropRef.instance.isShown = false;\n      /** @type {?} */\n\n      const duration = this.config.animated ? TRANSITION_DURATIONS.BACKDROP : 0;\n      setTimeout(\n      /**\n      * @return {?}\n      */\n      () => this.removeBackdrop(), duration);\n    } // tslint:disable-next-line:no-any\n\n    /**\n     * @param {?} content\n     * @return {?}\n     */\n\n\n    _showModal(content) {\n      var _a;\n      /** @type {?} */\n\n\n      const modalLoader = this.loaders[this.loaders.length - 1];\n\n      if (this.config && this.config.providers) {\n        for (const provider of this.config.providers) {\n          modalLoader.provide(provider);\n        }\n      }\n      /** @type {?} */\n\n\n      const bsModalRef = new BsModalRef();\n      /** @type {?} */\n\n      const modalContainerRef = modalLoader.provide({\n        provide: ModalOptions,\n        useValue: this.config\n      }).provide({\n        provide: BsModalRef,\n        useValue: bsModalRef\n      }).attach(ModalContainerComponent).to('body');\n\n      bsModalRef.hide =\n      /**\n      * @return {?}\n      */\n      () => modalContainerRef.instance.hide();\n\n      bsModalRef.setClass =\n      /**\n      * @param {?} newClass\n      * @return {?}\n      */\n      newClass => {\n        modalContainerRef.instance.config.class = newClass;\n      };\n\n      bsModalRef.onHidden = new EventEmitter();\n      bsModalRef.onHide = new EventEmitter();\n      this.copyEvent(modalLoader.onBeforeHide, bsModalRef.onHide);\n      this.copyEvent(modalLoader.onHidden, bsModalRef.onHidden); // call 'show' method after assign setClass in bsModalRef.\n      // it makes modal component's bsModalRef available to call setClass method\n\n      modalContainerRef.show({\n        content,\n        isAnimated: this.config.animated,\n        initialState: this.config.initialState,\n        bsModalService: this,\n        id: this.config.id\n      });\n      modalContainerRef.instance.level = this.getModalsCount();\n      bsModalRef.content = modalLoader.getInnerComponent() || null;\n      bsModalRef.id = (_a = modalContainerRef.instance.config) === null || _a === void 0 ? void 0 : _a.id;\n      return bsModalRef;\n    }\n    /**\n     * @param {?=} id\n     * @return {?}\n     */\n\n\n    _hideModal(id) {\n      if (id != null) {\n        /** @type {?} */\n        const indexToRemove = this.loaders.findIndex(\n        /**\n        * @param {?} loader\n        * @return {?}\n        */\n        loader => loader.instance.config.id === id);\n        /** @type {?} */\n\n        const modalLoader = this.loaders[indexToRemove];\n\n        if (modalLoader) {\n          modalLoader.hide(id);\n        }\n      } else {\n        this.loaders.forEach(\n        /**\n        * @param {?} loader\n        * @return {?}\n        */\n        loader => {\n          loader.hide(loader.instance.config.id);\n        });\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    getModalsCount() {\n      return this.modalsCount;\n    }\n    /**\n     * @param {?} reason\n     * @return {?}\n     */\n\n\n    setDismissReason(reason) {\n      this.lastDismissReason = reason;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    removeBackdrop() {\n      this._renderer.removeClass(document.body, CLASS_NAME.OPEN);\n\n      this._backdropLoader.hide();\n\n      this.backdropRef = null;\n    }\n    /** Checks if the body is overflowing and sets scrollbar width */\n\n    /**\n     * \\@internal\n     * @return {?}\n     */\n\n\n    checkScrollbar() {\n      this.isBodyOverflowing = document.body.clientWidth < window.innerWidth;\n      this.scrollbarWidth = this.getScrollbarWidth();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    setScrollbar() {\n      if (!document) {\n        return;\n      }\n\n      this.originalBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue('padding-right') || '0', 10);\n\n      if (this.isBodyOverflowing) {\n        document.body.style.paddingRight = `${this.originalBodyPadding + this.scrollbarWidth}px`;\n      }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    resetScrollbar() {\n      document.body.style.paddingRight = `${this.originalBodyPadding}px`;\n    } // thx d.walsh\n\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    getScrollbarWidth() {\n      /** @type {?} */\n      const scrollDiv = this._renderer.createElement('div');\n\n      this._renderer.addClass(scrollDiv, CLASS_NAME.SCROLLBAR_MEASURER);\n\n      this._renderer.appendChild(document.body, scrollDiv);\n      /** @type {?} */\n\n\n      const scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n\n      this._renderer.removeChild(document.body, scrollDiv);\n\n      return scrollbarWidth;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _createLoaders() {\n      /** @type {?} */\n      const loader = this.clf.createLoader(null, null, null);\n      this.copyEvent(loader.onBeforeShow, this.onShow);\n      this.copyEvent(loader.onShown, this.onShown);\n      this.copyEvent(loader.onBeforeHide, this.onHide);\n      this.copyEvent(loader.onHidden, this.onHidden);\n      this.loaders.push(loader);\n    }\n    /**\n     * @private\n     * @param {?=} id\n     * @return {?}\n     */\n\n\n    removeLoaders(id) {\n      if (id != null) {\n        /** @type {?} */\n        const indexToRemove = this.loaders.findIndex(\n        /**\n        * @param {?} loader\n        * @return {?}\n        */\n        loader => loader.instance.config.id === id);\n\n        if (indexToRemove >= 0) {\n          this.loaders.splice(indexToRemove, 1);\n          this.loaders.forEach(\n          /**\n          * @param {?} loader\n          * @param {?} i\n          * @return {?}\n          */\n          (loader, i) => {\n            loader.instance.level = i + 1;\n          });\n        }\n      } else {\n        this.loaders.splice(0, this.loaders.length);\n      }\n    } // tslint:disable-next-line:no-any\n\n    /**\n     * @private\n     * @param {?} from\n     * @param {?} to\n     * @return {?}\n     */\n\n\n    copyEvent(from, to) {\n      from.subscribe(\n      /**\n      * @param {?} data\n      * @return {?}\n      */\n      data => {\n        to.emit(this.lastDismissReason || data);\n      });\n    }\n\n  }\n\n  BsModalService.ɵfac = function BsModalService_Factory(t) {\n    return new (t || BsModalService)(ɵngcc0.ɵɵinject(ɵngcc0.RendererFactory2), ɵngcc0.ɵɵinject(ɵngcc1.ComponentLoaderFactory), ɵngcc0.ɵɵinject(MODAL_CONFIG_DEFAULT_OVERRIDE, 8));\n  };\n\n  BsModalService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: BsModalService,\n    factory: BsModalService.ɵfac\n  });\n  /** @nocollapse */\n\n  return BsModalService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /** @type {?} */\n  BsModalService.prototype.config;\n  /** @type {?} */\n\n  BsModalService.prototype.onShow;\n  /** @type {?} */\n\n  BsModalService.prototype.onShown;\n  /** @type {?} */\n\n  BsModalService.prototype.onHide;\n  /** @type {?} */\n\n  BsModalService.prototype.onHidden;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  BsModalService.prototype.isBodyOverflowing;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  BsModalService.prototype.originalBodyPadding;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  BsModalService.prototype.scrollbarWidth;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  BsModalService.prototype.backdropRef;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  BsModalService.prototype._backdropLoader;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  BsModalService.prototype.modalsCount;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  BsModalService.prototype.lastDismissReason;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  BsModalService.prototype.loaders;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  BsModalService.prototype._renderer;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  BsModalService.prototype.clf;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  BsModalService.prototype.modalDefaultOption;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet ModalModule = /*#__PURE__*/(() => {\n  class ModalModule {\n    /**\n     * @return {?}\n     */\n    static forRoot() {\n      return {\n        ngModule: ModalModule,\n        providers: [BsModalService, ComponentLoaderFactory, PositioningService]\n      };\n    }\n    /**\n     * @return {?}\n     */\n\n\n    static forChild() {\n      return {\n        ngModule: ModalModule,\n        providers: [BsModalService, ComponentLoaderFactory, PositioningService]\n      };\n    }\n\n  }\n\n  ModalModule.ɵfac = function ModalModule_Factory(t) {\n    return new (t || ModalModule)();\n  };\n\n  ModalModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: ModalModule\n  });\n  ModalModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return ModalModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ModalModule, {\n    declarations: [ModalBackdropComponent, ModalDirective, ModalContainerComponent],\n    exports: [ModalBackdropComponent, ModalDirective]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { BsModalRef, BsModalService, MODAL_CONFIG_DEFAULT_OVERRIDE, ModalBackdropComponent, ModalBackdropOptions, ModalContainerComponent, ModalDirective, ModalModule, ModalOptions, CLASS_NAME as ɵa }; //# sourceMappingURL=ngx-bootstrap-modal.js.map","map":null,"metadata":{},"sourceType":"module"}